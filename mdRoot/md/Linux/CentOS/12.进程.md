# 进程

现代操作系统比如Mac OS X，UNIX，Linux，Windows等，都是支持“多任务”的操作系统。

什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。

现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？

答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。

真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。

对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。

有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。

由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。

### 进程的分类

按照进程的功能和运行的程序分类，进程可划分为两大类：

#### 系统进程

可以执行内存资源分配和进程切换等管理工作，而且该进程的运行不受用户的干预，即使是root用户也不能干预系统进程的运行。

#### 用户进程

通过执行用户程序、应用程序或内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。

针对用户进程，又可以分为如下3类：

1. 交互进程：由一个Shell终端其他的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行于后台。
2. 批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。
3. 守护进程：守护进程是一直运行的一种进程，经常在Linux系统时启动，在系统关闭时终止。它们独立于控制终端且周期性地质学某种任务或等待处理某些发生的时间。例，httpd进程，crond进程等。


### 进程状态【选学】

为了充分的利用资源，系统还对进程区分了不同的状态。

一般操作系统将进程分为五个状态：

1. 新建：新建表示进程正在被创建。
2. 运行：运行是进程正在运行。
3. 阻塞：阻塞是进程正在等待某一个事件发生。
4. 就绪：就绪是表示系统正在等待CPU来执行命令。
5. 完成：完成表示进程已经结束了系统正在回收资源。


Linux上进程有5种状态，这5中状态可以与一般操作系统的状态对应起来：

1. 运行：正在运行或在运行队列中等待。
2. 中断：休眠中， 受阻， 在等待某个条件的形成或接受到信号。
3. 不可中断：收到信号不唤醒和不可运行， 进程必须等待直到有中断发生。
4. 僵死：进程已终止， 但进程描述符存在， 直到父进程调用wait4()系统调用后释放。
5. 停止：进程收到SIGSTOP， SIGSTP， SIGTIN， SIGTOU信号后停止运行运行。


### 父子进程和进程id

一个程序可能有许多进程，而每一个进程又可以有许多子进程。依次循环下去，而产生子孙进程。

为了区分各个不同的进程，系统给每一个进程分配了一个ID以便识别。Linux系统中，进程ID（PID）是区分不同进程的唯一标识。PPID表示父进程。所有的进程都是PID为1的init进程的后代。内核在系统启动的最后阶段启动init进程。

一般每个进程都会有父进程，父进程与子进程之间是管理与被管理的关系，一般情况下，当父进程停止时，子进程也随之消失，但子进程关闭，父进程不一定终止。

### 僵尸进程

每个进程在结束后都会处于**僵死**状态，等待父进程将其释放资源，处于该状态的进程已经结束，但父进程还没有释放其系统资源。

由于某种原因，父进程在子进程退出前退出，则所有子进程就变成一个孤儿进程，它没有相应处理机制，则孤儿进程会一直处于僵死状态，资源无法释放。这种僵死的孤儿进程即**僵尸进程**


### 线程和进程的区别：

1. 线程没有独立的内存地址空间，而进程有，每一个进程都有自己的一块独立的内存区域，互补干涉。
2. 线程不能独立存在，它是由进程创建的。
3. 一般来说，线程耗费的cpu和内存小小于进程

### 实现多任务的方式

有3种解决方案：

1. 一种是启动多个进程，每个进程虽然只有一个线程，但多个进程可以一块执行多个任务。
2. 还有一种方法是启动一个进程，在一个进程内启动多个线程，这样，多个线程也可以一块执行多个任务。
3. 启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了，当然这种模型更复杂，实际很少采用。

总结一下就是，多任务的实现有3种方式：

1. 多进程模式；
2. 多线程模式；
3. 多进程+多线程模式。

同时执行多个任务通常各个任务之间并不是没有关联的，而是需要相互通信和协调，有时，任务1必须暂停等待任务2完成后才能继续执行，有时，任务3和任务4又不能同时执行，所以，多进程和多线程的程序的复杂度要远远高于我们前面写的单进程单线程的程序。


### 进程状态监控

ps命令（Process Status）可以显示当前进程的状态。

ps命令有两种不同风格的语法规则：

BSD形式，BSD形式的语法的选项前没有破折号，如：`ps aux`

UNIX/LINUX形式，Linux形式的语法的选项前有破折号，如：`ps -ef`

在Linux系统上混合这两种语法是可以的。比如 "`ps ax -f`"。

注意："`ps aux`"不等同于"`ps -aux`"。比如"-u"用于显示用户的进程，但是"u"意味着显示具体信息。


`ps`常用选项：

```
a：显示终端中所有用户的所有进程
u: 显示用户的所有进程
x：通常与a一起使用，显示无控制终端的进程
r：显示当前终端的进程。
c：显示进程的真实名称。
e：显示环境变量。
f：显示程序间的关系。
T：显示当前终端的所有程序

-a：显示同一终端下的所有程序。
-A：显示所有进程。
-u：有效用户相关的进程。
-N：反向选择。
-f：详细显示程序执行的路径群。
-e ：所有进程。等同于-A。
-l ：显示长格式。
-F ：附加全格式。
-H ：显示进程的树状结构。
-L ：显示线程，可能出现LWP和NLWP栏位。
-m ：在进程后显示线程。
-h 不显示标题。
-w 宽输出。
--lines<行数> 每页显示的行数。
--width<字符数> 每页显示的字符数。
--help 显示帮助信息。
--version 显示版本显示。
```

常用例子:

```
ps aux
ps aux | grep ssh
```

#### 一些输出解释：

USER 进程的用户;

PID 进程的ID;

PPID 父进程;

%CPU 进程占用的CPU百分比;

%MEM 占用内存的百分比;

NI 进程的NICE值，数值大，表示较少占用CPU时间;

VSZ 进程虚拟大小;

RSS 驻留中页的数量;

TTY 终端ID

STAT 进程状态(有以下几种)
```
    D 无法中断的休眠状态(通常 IO 的进程);
    R 正在运行可中在队列中可过行的;
    S 处于休眠状态;
    T 停止或被追踪;
    W 进入内存交换(从内核2.6开始无效);
    X 死掉的进程;
    Z 僵尸进程;
    < 优先级高的进程
    N 优先级较低的进程
    L 有些页被锁进内存;
```
START: 行程开始时间

TIME: 执行的时间

COMMAND:所执行的指令


### 终止进程：`kill`

使用方式： 

```
kill 进程号

kill -9 进程号
```

### 动态查看进程状态：`top`

退出top：按键q